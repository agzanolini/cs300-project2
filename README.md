# cs300-project2

**What was the problem you were solving in the projects for this course?**
These projects were intended to take input from a file containing course information for a computer science major, and organize the information into a data structure of our choosing.  As part of the input process, the course information had to be checked to confirm it contained at least a course code and title, and any listed prerequisites existed as another course in the list. Then we had to be able to output a course list sorted in alphabetical order as well as output course and prerequisite details of a given course the user searches for.

**How did you approach the problem? Consider why data structures are important to understand.**
Given the requirements to confirm details of input information, output an alphabetical list, and search for a specific list item, consideration must be given to how to organize information from the input document into a data structure.  Familiarity with various data structures can help to best choose the most efficient method to organize the input data.  Linked lists are simpler structures to construct but the worst case big O notation for sorting the data into alphabetical order is O(n^2) and searching the list is O(n), having to compare each list entry to the search item in order.  Hash tables are more complicated to construct and are by nature unsorted, but have a big O notation of O(1) when searching for a particular item because of the use of a hash key to map the data to a particular location which can be found virtually instantly.  Binary search trees are more complicated to construct and do not always lend themselves to the particular hierarchy of how the input data is organized, but can have a big O notation of between O(log2n) and O(n) when searching for items depending on its organization.  An advantage of trees is that items are sorted as they are added to the tree, making traversing to output an ordered list much simpler.  Keeping these advantages and disadvantages in mind can lead to more organized software design and a more efficient final product.

**How did you overcome any roadblocks you encountered while going through the activities or project?**
I referenced our textbook and online resources when struggling with the bid-sorting activities, and was able to construct pseudocode for my final project based on the organization of the activities as well.  Working extensively with pseudocode allowed me to think ahead for constructing my final project, but I inevitably had to address unforeseen issues as I started to write my code.  I continued to look up online resources when problems arose, like when my input items unexpectedly had unicode characters attached which prevented hashing from working properly.  I had hoped that hashing a converted ASCII value of the course code would result in inserting the courses in alphabetical order, but when many versions of that attempt that was unsuccessful I moved on to a simpler hashing method and resolved to import the course items into a linked list to bubble sort.  If the input document was larger, this would result in much slower code but given that the final product had to both list and search items, inevitably one function was going to be slow.  I ultimately did a lot of troubleshooting, but also gave myself time to walk away and take short breaks, which I found allowed me to come back refreshed.  Some problems that had stumped me were suddenly easy to solve after some time away.

**How has your work on this project expanded your approach to designing software and developing programs?**
This project made me see the benefit of investing time in the intial design and layout process.  Familiarity with various data structures also has given me the tools to approach the needs of future projects from an informed perspective and with consideration for the worst-case runtime.

**How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?**
This work has evolved my use of pointers, objects, and constant variables to allow for the best use of the code's structure without limiting its usefulness when input varies.
